import { Injectable, NotFoundException } from '@nestjs/common';
import { UsersRepository } from './users.repository';
import { User } from '../../entities/user.entity';
import * as crypto from 'crypto';
import { promisify } from 'util';
import { UserRole } from 'src/utils/roles.enum';
import { UserInput } from './dto/user.input';

// Promisify the crypto functions
const scrypt = promisify(crypto.scrypt);
const randomBytes = promisify(crypto.randomBytes);

@Injectable()
export class UsersService {
  private readonly passwordCharset =
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+';
  constructor(private readonly usersRepository: UsersRepository) {}

  async findById(id: string): Promise<User> {
    const user = await this.usersRepository.findById(id);
    if (!user) {
      throw new NotFoundException(`Usuário com ID ${id} não encontrado`);
    }
    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.usersRepository.findByEmail(email);
  }

  async delete(id: string): Promise<void> {
    await this.findById(id); // Verifica se o usuário existe
    await this.usersRepository.delete(id);
  }

  async findAll(): Promise<User[]> {
    return this.usersRepository.findAll();
  }

  async upsertUser(
    data: UserInput,
    currentUser?: User,
  ): Promise<User & { generatedPassword?: string }> {
    const isUpdate = !!data.id;

    // Aplicar auto-vinculação com o profissional atual se necessário
    data = this.applyProfessionalAutoLink(data, currentUser);

    // Common validation logic for both update and insert
    await this.validateProfessionalRelationships(data, isUpdate);

    // Handle password encoding
    const { processedData, rawPassword } = await this.processPassword(data);

    if (isUpdate) {
      // Update existing user
      const updatedUser = await this.usersRepository.update(
        data.id,
        processedData,
      );
      if (!updatedUser) {
        throw new NotFoundException(
          `Não foi possível atualizar o usuário com ID ${data.id}`,
        );
      }
      return updatedUser;
    } else {
      // Create new user
      const user = await this.usersRepository.create(processedData);

      // Handle auto-generated password if necessary
      if (processedData.isPasswordAutoGenerated) {
        const updatedUser = await this.usersRepository.update(user.id, {
          isPasswordAutoGenerated: true,
        });

        // Return the user with the generated password
        return {
          ...(updatedUser || user),
          generatedPassword: rawPassword,
        };
      }

      return user;
    }
  }

  private applyProfessionalAutoLink(
    data: UserInput,
    currentUser?: User,
  ): UserInput {
    if (!currentUser || data.trainerId || data.nutritionistId) {
      return data;
    }

    if (
      currentUser.role === UserRole.TRAINER &&
      (data.role === UserRole.CLIENT || !data.role)
    ) {
      if (data.trainerId === undefined) {
        return { ...data, trainerId: currentUser.id };
      }
    }

    if (
      currentUser.role === UserRole.NUTRITIONIST &&
      (data.role === UserRole.CLIENT || !data.role)
    ) {
      if (data.nutritionistId === undefined) {
        return { ...data, nutritionistId: currentUser.id };
      }
    }

    return data;
  }

  private async validateClientRelationships(
    data: UserInput,
    existingUser: User | null,
  ): Promise<void> {
    if (
      !existingUser &&
      data.role === UserRole.CLIENT &&
      !data.trainerId &&
      !data.nutritionistId
    ) {
      throw new Error(
        'Um cliente deve estar associado a pelo menos um treinador ou nutricionista',
      );
    }

    if (existingUser && existingUser.role === UserRole.CLIENT) {
      const isRemovingTrainer = data.trainerId === null;
      const isRemovingNutritionist = data.nutritionistId === null;

      if (isRemovingTrainer && isRemovingNutritionist) {
        throw new Error(
          'Não é possível remover ambas as relações. Um cliente deve estar vinculado a pelo menos um treinador ou nutricionista.',
        );
      }

      const willHaveTrainer = isRemovingTrainer
        ? false
        : data.trainerId !== undefined
          ? data.trainerId
          : existingUser.trainerId;
      const willHaveNutritionist = isRemovingNutritionist
        ? false
        : data.nutritionistId !== undefined
          ? data.nutritionistId
          : existingUser.nutritionistId;

      if (!willHaveTrainer && !willHaveNutritionist) {
        throw new Error(
          'Após a atualização, o cliente ficaria sem vínculos. Um cliente deve estar vinculado a pelo menos um treinador ou nutricionista.',
        );
      }
    }
  }

  private async validateProfessionalRelationships(
    data: UserInput,
    isUpdate: boolean,
  ): Promise<void> {
    // For update operations, retrieve existing user data
    let existingUser: User | null = null;
    if (isUpdate && data.id) {
      existingUser = await this.findById(data.id);
    }

    // Client specific validations
    const isClient =
      existingUser?.role === UserRole.CLIENT || data.role === UserRole.CLIENT;
    if (isClient) {
      await this.validateClientRelationships(data, existingUser);
    }

    // Professional specific validations
    const isProfessional =
      data.role === UserRole.TRAINER || data.role === UserRole.NUTRITIONIST;
    if (isProfessional && (data.trainerId || data.nutritionistId)) {
      throw new Error(
        'Treinadores e nutricionistas não devem estar vinculados a outros profissionais',
      );
    }

    // Validate professional roles where relevant
    await this.validateProfessionalRoles(data);
  }

  private async validateProfessionalRoles(data: UserInput): Promise<void> {
    if (data.trainerId) {
      const trainer = await this.findById(data.trainerId);
      if (trainer.role !== UserRole.TRAINER) {
        throw new Error(
          'O usuário selecionado como treinador não tem o papel de treinador',
        );
      }
    }

    if (data.nutritionistId) {
      const nutritionist = await this.findById(data.nutritionistId);
      if (nutritionist.role !== UserRole.NUTRITIONIST) {
        throw new Error(
          'O usuário selecionado como nutricionista não tem o papel de nutricionista',
        );
      }
    }
  }

  private async processPassword(data: UserInput): Promise<{
    processedData: Partial<User> & UserInput;
    rawPassword: string;
  }> {
    const processedData: Partial<User> & UserInput = { ...data };
    let rawPassword: string = data.password || '';

    if (!data.password && !data.id) {
      // Generate password for new users without password
      const generatedPassword = this.generateRandomPassword();
      rawPassword = generatedPassword;
      processedData.password = await this.encodePassword(generatedPassword);
      processedData.isPasswordAutoGenerated = true;
    } else if (data.password) {
      // Encode provided password
      processedData.password = await this.encodePassword(data.password);
    }

    return { processedData, rawPassword };
  }

  private generateRandomPassword(length = 12): string {
    const charset = this.passwordCharset;
    let password = '';

    password += charset.substring(0, 26).charAt(Math.floor(Math.random() * 26));
    password += charset
      .substring(26, 52)
      .charAt(Math.floor(Math.random() * 26));
    password += charset
      .substring(52, 62)
      .charAt(Math.floor(Math.random() * 10));
    password += charset
      .substring(62)
      .charAt(Math.floor(Math.random() * (charset.length - 62)));

    // Fill the rest of the password
    for (let i = 4; i < length; i++) {
      const randomIndex = crypto.randomInt(0, charset.length);
      password += charset.charAt(randomIndex);
    }

    // Shuffle the password
    return password
      .split('')
      .sort(() => 0.5 - Math.random())
      .join('');
  }

  /**
   * Encodes a password using scrypt for secure storage in a database
   * @param plainPassword The plain text password to encode
   * @returns A Promise that resolves to the hashed password string
   */
  private async encodePassword(plainPassword: string): Promise<string> {
    try {
      // Generate a random salt
      const salt = await randomBytes(16);

      // Hash the password with the salt
      const derivedKey = (await scrypt(plainPassword, salt, 64)) as Buffer;

      // Format as [salt]:[derived key]
      return salt.toString('hex') + ':' + derivedKey.toString('hex');
    } catch (error) {
      console.error('Error encoding password:', error);
      throw new Error('Password encoding failed');
    }
  }

  /**
   * Verifies a password against a stored scrypt hash
   * @param plainPassword The plain text password to verify
   * @param hashedPassword The stored hashed password (salt:hash format)
   * @returns A Promise that resolves to true if password matches, false otherwise
   */
  async verifyPassword(
    plainPassword: string,
    hashedPassword: string,
  ): Promise<boolean> {
    try {
      // Split the stored hash into salt and hash portions
      const [salt, storedHash] = hashedPassword.split(':');

      // Hash the input password with the same salt
      const derivedKey = (await scrypt(
        plainPassword,
        Buffer.from(salt, 'hex'),
        64,
      )) as Buffer;

      // Compare the derived key with the stored hash
      return crypto.timingSafeEqual(Buffer.from(storedHash, 'hex'), derivedKey);
    } catch (error) {
      console.error('Error verifying password:', error);
      throw new Error('Password verification failed');
    }
  }

  async getClientsForTrainer(trainerId: string): Promise<User[]> {
    const trainer = await this.findById(trainerId);
    if (trainer.role !== UserRole.TRAINER) {
      throw new Error('Usuário não é um treinador');
    }
    return this.usersRepository.findClientsForTrainer(trainerId);
  }

  async getClientsForNutritionist(nutritionistId: string): Promise<User[]> {
    const nutritionist = await this.findById(nutritionistId);
    if (nutritionist.role !== UserRole.NUTRITIONIST) {
      throw new Error('Usuário não é um nutricionista');
    }
    return this.usersRepository.findClientsForNutritionist(nutritionistId);
  }

  async assignClientToTrainer(
    clientId: string,
    trainerId: string,
  ): Promise<User | null> {
    const trainer = await this.findById(trainerId);

    if (trainer.role !== UserRole.TRAINER) {
      throw new Error('Usuário não é um treinador');
    }

    return this.usersRepository.update(clientId, { trainerId });
  }

  async assignClientToNutritionist(
    clientId: string,
    nutritionistId: string,
  ): Promise<User | null> {
    const nutritionist = await this.findById(nutritionistId);

    if (nutritionist.role !== UserRole.NUTRITIONIST) {
      throw new Error('Usuário não é um nutricionista');
    }

    return this.usersRepository.update(clientId, { nutritionistId });
  }

  async getClientForProfessional(
    clientId: string,
    professionalId: string,
  ): Promise<User> {
    const client = await this.usersRepository.findClientById(
      clientId,
      professionalId,
    );
    if (!client) {
      throw new NotFoundException(
        'Cliente não encontrado ou não está associado a esse profissional',
      );
    }
    return client;
  }
}
